/**
 * COMPRAS MODULE - Utilitários Centralizados
 * @description Biblioteca de funções utilitárias para o módulo de Compras
 * @version 2.0.0 - Enterprise Grade
 * @author ALUFORCE Team
 */

(function(global) {
    'use strict';

    // ============================================
    // CONSTANTES E CONFIGURAÇÕES
    // ============================================

    const CONFIG = Object.freeze({
        // Cores do tema (usar CSS variables preferencialmente)
        COLORS: Object.freeze({
            SUCCESS: 'var(--success, #22c55e)',
            ERROR: 'var(--danger, #ef4444)',
            WARNING: 'var(--warning, #f59e0b)',
            INFO: 'var(--info, #3b82f6)',
            PRIMARY: 'var(--compras-primary, #6366f1)'


















































































































































































































































































































































































































































































































































































































































































































































})(typeof window !== 'undefined' ? window : this);    console.log('✅ [ComprasUtils] Módulo de utilitários carregado v2.0.0');    global.mostrarToast = (msg, type) => toast.show(msg, type);    // Alias global para toast (retrocompatibilidade)    };        getGreeting: Utils.getGreeting        debounce: Utils.debounce,        escapeHtml: Utils.escapeHtml,        formatCNPJ: Formatters.cnpj,        formatData: Formatters.data,        formatMoeda: Formatters.moeda,        showToast: (msg, type) => toast.show(msg, type),        // Atalhos convenientes                avatar,        api,        toast,        // Instâncias singleton                Utils,        Validators,        Formatters,        // Utilitários                ValidationError,        ApiError,        // Erros customizados                AvatarManager,        ApiClient,        ToastManager,        // Classes                CONFIG,        // Configurações    global.ComprasUtils = {    // Exportar namespace    const avatar = new AvatarManager();    const api = new ApiClient();    const toast = new ToastManager();    // Singleton instances        // ============================================    // EXPORTAR PARA GLOBAL    // ============================================    }        }            container.appendChild(badge);            `;                border-radius: 50%;                border: 2px solid white;                background: ${statusColors[status] || statusColors.offline};                height: ${badgeSize}px;                width: ${badgeSize}px;                right: 0;                bottom: 0;                position: absolute;            badge.style.cssText = `                        };                offline: '#94a3b8'                away: '#f59e0b',                busy: '#ef4444',                online: '#22c55e',            const statusColors = {            const badgeSize = Math.max(8, Math.floor(size * 0.25));            const badge = document.createElement('span');        _addStatusBadge(container, status, size) {        }            return this.fallbackColors[Math.abs(hash) % this.fallbackColors.length];            }                hash = name.charCodeAt(i) + ((hash << 5) - hash);            for (let i = 0; i < name.length; i++) {            let hash = 0;            if (!name) return this.fallbackColors[0];        _getColorFromName(name) {        }            return url.startsWith('/') || url.startsWith('http');            if (url === this.defaultAvatar) return true;            if (url.includes('undefined') || url.includes('null')) return false;            if (!url) return false;        _isValidUrl(url) {        }            }                if (showStatus) this._addStatusBadge(container, status, size);                container.innerHTML = `<span class="user-initial">${initial}</span>`;            } else {                img.src = photoUrl;                                };                    if (showStatus) this._addStatusBadge(container, status, size);                    container.innerHTML = `<span class="user-initial">${initial}</span>`;                img.onerror = () => {                                };                    if (showStatus) this._addStatusBadge(container, status, size);                    container.appendChild(img);                    container.innerHTML = '';                img.onload = () => {                                img.style.cssText = 'width:100%;height:100%;object-fit:cover;';                img.alt = name;                const img = document.createElement('img');            if (photoUrl && this._isValidUrl(photoUrl)) {            `;                position: relative;                font-size: ${Math.floor(size * 0.4)}px;                font-weight: 600;                color: white;                background: ${bgColor};                justify-content: center;                align-items: center;                display: flex;                overflow: hidden;                border-radius: 50%;                height: ${size}px;                width: ${size}px;            container.style.cssText = `            const bgColor = this._getColorFromName(name);            const initial = Utils.getInitials(name, 1);            } = options;                status = 'offline'                showStatus = false,                size = 36,                name = 'Usuário',                photoUrl,            const {        render(container, options = {}) {         */         * Renderiza avatar com fallback robusto        /**        }            ];                '#f59e0b', '#22c55e', '#14b8a6', '#3b82f6'                '#6366f1', '#8b5cf6', '#ec4899', '#ef4444',            this.fallbackColors = [            this.defaultAvatar = '/avatars/default.webp';        constructor() {    class AvatarManager {        // ============================================    // AVATAR MANAGER - Gerenciamento de Avatar    // ============================================    };        }            }                }                    await this.sleep(delay * (i + 1));                    if (i === attempts - 1) throw error;                } catch (error) {                    return await fn();                try {            for (let i = 0; i < attempts; i++) {        async retry(fn, attempts = CONFIG.MAX_RETRY_ATTEMPTS, delay = 1000) {         */         * Faz retry de função assíncrona        /**        },            return new Promise(resolve => setTimeout(resolve, ms));        sleep(ms) {         */         * Aguarda millisegundos        /**        },                .join('');                .map(n => n[0].toUpperCase())                .slice(0, count)                .filter(n => n.length > 0)                .split(' ')            return name            if (!name) return 'U';        getInitials(name, count = 2) {         */         * Obtém iniciais do nome        /**        },            return 'Boa noite';            if (hour >= 12 && hour < 18) return 'Boa tarde';            if (hour >= 5 && hour < 12) return 'Bom dia';            const hour = new Date().getHours();        getGreeting() {         */         * Retorna saudação baseada na hora        /**        },            return (item && typeof item === 'object' && !Array.isArray(item));        isObject(item) {        },            return this.deepMerge(target, ...sources);            }                }                    }                        Object.assign(target, { [key]: source[key] });                    } else {                        this.deepMerge(target[key], source[key]);                        if (!target[key]) Object.assign(target, { [key]: {} });                    if (this.isObject(source[key])) {                for (const key in source) {            if (this.isObject(target) && this.isObject(source)) {            const source = sources.shift();            if (!sources.length) return target;        deepMerge(target, ...sources) {         */         * Faz merge profundo de objetos        /**        },            return JSON.parse(JSON.stringify(obj));            if (obj === null || typeof obj !== 'object') return obj;        deepClone(obj) {         */         * Deep clone de objeto        /**        },            return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;        generateId(prefix = 'id') {         */         * Gera ID único        /**        },            return div.innerHTML;            div.textContent = text;            const div = document.createElement('div');            if (!text) return '';        escapeHtml(text) {         */         * Escapa HTML para prevenir XSS        /**        },            };                }                    setTimeout(() => inThrottle = false, limit);                    inThrottle = true;                    func.apply(this, args);                if (!inThrottle) {            return function(...args) {            let inThrottle;        throttle(func, limit) {         */         * Throttle para limitar execuções        /**        },            };                timeout = setTimeout(later, wait);                clearTimeout(timeout);                };                    func(...args);                    clearTimeout(timeout);                const later = () => {            return function executedFunction(...args) {            let timeout;        debounce(func, wait = CONFIG.DEBOUNCE_DELAY) {         */         * Debounce para evitar chamadas excessivas        /**    const Utils = {        // ============================================    // UTILIDADES GERAIS    // ============================================    };        }            return num >= min && num <= max;            if (isNaN(num)) return false;            const num = parseFloat(value);        range(value, min, max) {        },            return String(value).length <= max;            if (!value) return true;        maxLength(value, max) {        },            return String(value).length >= min;            if (!value) return false;        minLength(value, min) {        },            return true;            if (typeof value === 'string') return value.trim().length > 0;            if (value === null || value === undefined) return false;        required(value) {        },            return clean.length >= 10 && clean.length <= 11;            const clean = tel.replace(/\D/g, '');            if (!tel) return false;        telefone(tel) {        },            return regex.test(email);            const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;            if (!email) return false;        email(email) {        },            return resto === parseInt(clean.charAt(10));            if (resto === 10 || resto === 11) resto = 0;            resto = (soma * 10) % 11;            }                soma += parseInt(clean.charAt(i)) * (11 - i);            for (let i = 0; i < 10; i++) {            soma = 0;                        if (resto !== parseInt(clean.charAt(9))) return false;            if (resto === 10 || resto === 11) resto = 0;            let resto = (soma * 10) % 11;            }                soma += parseInt(clean.charAt(i)) * (10 - i);            for (let i = 0; i < 9; i++) {            let soma = 0;                        if (/^(\d)\1{10}$/.test(clean)) return false;            if (clean.length !== 11) return false;            const clean = cpf.replace(/\D/g, '');            if (!cpf) return false;        cpf(cpf) {        },            return resultado === parseInt(digitos.charAt(1));            resultado = soma % 11 < 2 ? 0 : 11 - soma % 11;                        }                if (pos < 2) pos = 9;                soma += numeros.charAt(tamanho - i) * pos--;            for (let i = tamanho; i >= 1; i--) {                        pos = tamanho - 7;            soma = 0;            numeros = clean.substring(0, tamanho);            tamanho = tamanho + 1;                        if (resultado !== parseInt(digitos.charAt(0))) return false;            let resultado = soma % 11 < 2 ? 0 : 11 - soma % 11;                        }                if (pos < 2) pos = 9;                soma += numeros.charAt(tamanho - i) * pos--;            for (let i = tamanho; i >= 1; i--) {                        let pos = tamanho - 7;            let soma = 0;            const digitos = clean.substring(tamanho);            let numeros = clean.substring(0, tamanho);            let tamanho = clean.length - 2;            // Validação de CNPJ usando módulo 11                        if (clean.length !== 14) return false;            const clean = cnpj.replace(/\D/g, '');            if (!cnpj) return false;        cnpj(cnpj) {    const Validators = {        // ============================================    // VALIDADORES    // ============================================    };        }            return texto.substring(0, maxLen - 3) + '...';            if (texto.length <= maxLen) return texto;            if (!texto) return '';        truncar(texto, maxLen = 50) {         */         * @returns {string}         * @param {number} maxLen          * @param {string} texto          * Trunca texto longo com ellipsis        /**        },            }).format(num);                maximumFractionDigits: decimais                minimumFractionDigits: decimais,            return new Intl.NumberFormat('pt-BR', {            if (num === null || num === undefined) return '0';        numero(num, decimais = 0) {         */         * @returns {string}         * @param {number} decimais          * @param {number} num          * Formata número com separador de milhares        /**        },            return d.toLocaleDateString('pt-BR', options);                        }                options.minute = '2-digit';                options.hour = '2-digit';            if (comHora) {                        };                year: 'numeric'                month: '2-digit',                day: '2-digit',            const options = {                        if (isNaN(d.getTime())) return '-';            const d = new Date(data);            if (!data) return '-';        data(data, comHora = false) {         */         * @returns {string}         * @param {boolean} comHora          * @param {string|Date} data          * Formata data para pt-BR        /**        },            return tel;            }                return clean.replace(/(\d{2})(\d{4})(\d{4})/, '($1) $2-$3');            if (clean.length === 10) {            }                return clean.replace(/(\d{2})(\d{5})(\d{4})/, '($1) $2-$3');            if (clean.length === 11) {            const clean = tel.replace(/\D/g, '');            if (!tel) return '-';        telefone(tel) {         */         * @returns {string}         * @param {string} tel          * Formata telefone        /**        },            return clean.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');            if (clean.length !== 11) return cpf;            const clean = cpf.replace(/\D/g, '');            if (!cpf) return '-';        cpf(cpf) {         */         * @returns {string}         * @param {string} cpf          * Formata CPF: 000.000.000-00        /**        },            return clean.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');            if (clean.length !== 14) return cnpj;            const clean = cnpj.replace(/\D/g, '');            if (!cnpj) return '-';        cnpj(cnpj) {         */         * @returns {string}         * @param {string} cnpj          * Formata CNPJ: 00.000.000/0000-00        /**        },            }).format(valor);                currency: 'BRL'                style: 'currency',            return new Intl.NumberFormat('pt-BR', {            if (valor === null || valor === undefined) return 'R$ 0,00';        moeda(valor) {         */         * @returns {string}         * @param {number} valor          * Formata valor monetário em Real brasileiro        /**    const Formatters = {        // ============================================    // FORMATADORES    // ============================================    }        }            this.field = field;            this.name = 'ValidationError';            super(message);        constructor(message, field) {    class ValidationError extends Error {    }        }            this.statusCode = statusCode;            this.name = 'ApiError';            super(message);        constructor(message, statusCode) {    class ApiError extends Error {        // ============================================    // CUSTOM ERRORS    // ============================================    }        }            return this._request(url, { method: 'DELETE' });        delete(url) {                }            });                body: JSON.stringify(data)                method: 'PATCH',            return this._request(url, {        patch(url, data) {                }            });                body: JSON.stringify(data)                method: 'PUT',            return this._request(url, {        put(url, data) {                }            });                body: JSON.stringify(data)                method: 'POST',            return this._request(url, {        post(url, data) {                get(url) { return this._request(url); }        }            }                throw error;                }                    throw new ApiError('Timeout: Servidor não respondeu', 408);                if (error.name === 'AbortError') {                                clearTimeout(timeoutId);            } catch (error) {                return await response.json();                }                    throw new ApiError(error.message || `HTTP ${response.status}`, response.status);                    const error = await response.json().catch(() => ({}));                if (!response.ok) {                clearTimeout(timeoutId);                });                    signal: controller.signal                    headers: { ...this._getAuthHeaders(), ...options.headers },                    ...options,                const response = await fetch(this.baseUrl + url, {            try {            const timeoutId = setTimeout(() => controller.abort(), CONFIG.API_TIMEOUT);            const controller = new AbortController();        async _request(url, options = {}) {        }            };                'Authorization': token ? `Bearer ${token}` : ''                'Content-Type': 'application/json',            return {            const token = localStorage.getItem('token') || sessionStorage.getItem('token');        _getAuthHeaders() {        }            this.baseUrl = baseUrl;        constructor(baseUrl = '') {    class ApiClient {        // ============================================    // API CLIENT - COMUNICAÇÃO COM BACKEND    // ============================================    }        info(message) { return this.show(message, 'info'); }        warning(message) { return this.show(message, 'warning'); }        error(message) { return this.show(message, 'error'); }        success(message) { return this.show(message, 'success'); }        }            return div.innerHTML;            div.textContent = text;            const div = document.createElement('div');        _escapeHtml(text) {        }            }, 300);                this.toasts = this.toasts.filter(t => t !== toast);                toast.remove();            setTimeout(() => {            toast.classList.add('removing');                        if (!toast || !toast.parentNode) return;        _removeToast(toast) {        }            return toast;            }                setTimeout(() => this._removeToast(toast), CONFIG.TOAST_DURATION);                this.toasts.push(toast);                container.appendChild(toast);            if (container) {            const container = document.getElementById(this.containerId);            `;                <span>${this._escapeHtml(message)}</span>                <i class="fas fa-${CONFIG.ICONS[type] || CONFIG.ICONS.info}"></i>            toast.innerHTML = `            toast.className = `toast-notification ${type}`;            const toast = document.createElement('div');            }                this._removeToast(this.toasts[0]);            while (this.toasts.length >= CONFIG.MAX_TOASTS) {            // Limpar toasts excedentes        show(message, type = 'info') {        }            document.body.appendChild(container);            container.className = 'toast-container';            container.id = this.containerId;            const container = document.createElement('div');                        if (document.getElementById(this.containerId)) return;        _createContainer() {        }            document.head.appendChild(style);            `;                .toast-notification.info { background: var(--info, #3b82f6); }                .toast-notification.warning { background: var(--warning, #f59e0b); }                .toast-notification.error { background: var(--danger, #ef4444); }                .toast-notification.success { background: var(--success, #22c55e); }                }                    animation: toastSlideOut 0.3s ease forwards;                .toast-notification.removing {                }                    backdrop-filter: blur(10px);                    max-width: 380px;                    animation: toastSlideIn 0.3s ease forwards;                    box-shadow: 0 10px 30px rgba(0,0,0,0.2);                    font-weight: 500;                    font-size: 14px;                    color: white;                    border-radius: 12px;                    padding: 16px 24px;                    gap: 12px;                    align-items: center;                    display: flex;                .toast-notification {                }                    gap: 10px;                    flex-direction: column;                    display: flex;                    z-index: 10000;                    right: 20px;                    top: 20px;                    position: fixed;                .toast-container {                }                    to { transform: translateX(100%); opacity: 0; }                    from { transform: translateX(0); opacity: 1; }                @keyframes toastSlideOut {                }                    to { transform: translateX(0); opacity: 1; }                    from { transform: translateX(100%); opacity: 0; }                @keyframes toastSlideIn {            style.textContent = `            style.id = 'toast-styles';            const style = document.createElement('style');                        if (document.getElementById('toast-styles')) return;        _injectStyles() {        }            this._createContainer();            this._injectStyles();            this.containerId = 'toast-container';            this.toasts = [];        constructor() {    class ToastManager {        // ============================================    // CLASSE DE TOAST NOTIFICATION    // ============================================    });        MAX_RETRY_ATTEMPTS: 3        MAX_TOASTS: 3,        // Limites                DEBOUNCE_DELAY: 300,        API_TIMEOUT: 10000,        TOAST_DURATION: 4000,        // Timeouts                }),            info: 'info-circle'            warning: 'exclamation-triangle',            error: 'exclamation-circle',            success: 'check-circle',        ICONS: Object.freeze({        // Ícones por tipo de notificação                }),
