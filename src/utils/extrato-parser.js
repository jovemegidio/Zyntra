/** * Parser de arquivos OFX e CSV para importação de extratos bancários * ALUFORCE ERP - Módulo Financeiro *//** * Parser de arquivo OFX (Open Financial Exchange) * Formato usado por bancos brasileiros e internacionais */function parseOFX(content) {    const transactions = [];        try {        // Encontrar o bloco de transações        const stmtTrnRegex = /<STMTTRN>([\s\S]*?)<\/STMTTRN>/gi;        let match;                while ((match = stmtTrnRegex.exec(content)) !== null) {            const trn = match[1];                        // Extrair campos da transação            const trntype = extractOFXField(trn, 'TRNTYPE');            const dtposted = extractOFXField(trn, 'DTPOSTED');            const trnamt = extractOFXField(trn, 'TRNAMT');            const fitid = extractOFXField(trn, 'FITID');            const checknum = extractOFXField(trn, 'CHECKNUM');            const memo = extractOFXField(trn, 'MEMO');            const name = extractOFXField(trn, 'NAME');                        // Converter data OFX (YYYYMMDD ou YYYYMMDDHHMMSS)            let dataTransacao = null;            if (dtposted) {                const ano = dtposted.substring(0, 4);                const mes = dtposted.substring(4, 6);                const dia = dtposted.substring(6, 8);                dataTransacao = `${ano}-${mes}-${dia}`;            }                        // Converter valor (pode ter vírgula ou ponto)            const valor = parseFloat(trnamt.replace(',', '.')) || 0;                        // Determinar tipo (entrada/saída)            const tipo = valor >= 0 ? 'entrada' : 'saida';                        transactions.push({                id_externo: fitid || `OFX_${Date.now()}_${transactions.length}`,                data: dataTransacao,                descricao: memo || name || 'Transação sem descrição',                valor: Math.abs(valor),                tipo: tipo,                tipo_transacao: trntype || 'OTHER',                numero_cheque: checknum || null,                origem: 'OFX'            });        }                // Extrair informações da conta        const bankid = extractOFXField(content, 'BANKID');        const acctid = extractOFXField(content, 'ACCTID');        const accttype = extractOFXField(content, 'ACCTTYPE');        const balamt = extractOFXField(content, 'BALAMT');                return {            success: true,            conta: {                banco: bankid,                conta: acctid,                tipo: accttype,                saldo: balamt ? parseFloat(balamt.replace(',', '.')) : null            },            transacoes: transactions,            total: transactions.length        };            } catch (error) {        return {            success: false,            error: error.message,            transacoes: [],            total: 0        };    }}/** * Extrai um campo de um bloco OFX */function extractOFXField(content, fieldName) {    // Formato: <FIELDNAME>valor ou <FIELDNAME>valor</FIELDNAME>    const regex1 = new RegExp(`<${fieldName}>([^<\\\r]+)`, 'i');    const regex2 = new RegExp(`<${fieldName}>([\\s\\S]*?)<\\/${fieldName}>`, 'i');        let match = content.match(regex2);    if (match) return match[1].trim();        match = content.match(regex1);    if (match) return match[1].trim();        return null;}/** * Parser de arquivo CSV * Suporta diferentes formatos de bancos brasileiros */function parseCSV(content, options = {}) {    const {        separador = ';',        colunaData = 0,        colunaDescricao = 1,        colunaValor = 2,        colunaTipo = null,        formatoData = 'DD/MM/YYYY',        temCabecalho = true    } = options;        const transactions = [];    const linhas = content.split(/\r?/).filter(l => l.trim());        try {        for (let i = temCabecalho ? 1 : 0; i < linhas.length; i++) {            const linha = linhas[i];            const colunas = parseCSVLine(linha, separador);                        if (colunas.length < 3) continue;                        // Extrair data            const dataStr = colunas[colunaData]?.trim();            const dataTransacao = parseDataCSV(dataStr, formatoData);                        // Extrair descrição            const descricao = colunas[colunaDescricao]?.trim() || 'Transação';                        // Extrair valor            let valorStr = colunas[colunaValor]?.trim() || '0';            // Limpar formatação brasileira (1.234,56)            valorStr = valorStr.replace(/\./g, '').replace(',', '.');            const valor = parseFloat(valorStr) || 0;                        // Determinar tipo            let tipo = 'entrada';            if (colunaTipo !== null && colunas[colunaTipo]) {                const tipoStr = colunas[colunaTipo].toLowerCase();                if (tipoStr.includes('deb') || tipoStr.includes('sai') || tipoStr.includes('pag')) {                    tipo = 'saida';                }            } else {                tipo = valor < 0 ? 'saida' : 'entrada';            }                        transactions.push({                id_externo: `CSV_${Date.now()}_${i}`,                data: dataTransacao,                descricao: descricao,                valor: Math.abs(valor),                tipo: tipo,                tipo_transacao: 'OTHER',                numero_cheque: null,                origem: 'CSV'            });        }                return {            success: true,            transacoes: transactions,            total: transactions.length        };            } catch (error) {        return {            success: false,            error: error.message,            transacoes: [],            total: 0        };    }}/** * Parse uma linha CSV considerando aspas */function parseCSVLine(linha, separador) {    const resultado = [];    let atual = '';    let dentroAspas = false;        for (let i = 0; i < linha.length; i++) {        const char = linha[i];                if (char === '"') {            dentroAspas = !dentroAspas;        } else if (char === separador && !dentroAspas) {            resultado.push(atual);            atual = '';        } else {            atual += char;        }    }    resultado.push(atual);        return resultado;}/** * Parse data no formato brasileiro */function parseDataCSV(dataStr, formato) {    if (!dataStr) return null;        try {        if (formato === 'DD/MM/YYYY') {            const partes = dataStr.split('/');            if (partes.length === 3) {                const dia = partes[0].padStart(2, '0');                const mes = partes[1].padStart(2, '0');                let ano = partes[2];                if (ano.length === 2) ano = '20' + ano;                return `${ano}-${mes}-${dia}`;            }        } else if (formato === 'YYYY-MM-DD') {            return dataStr;        } else if (formato === 'MM/DD/YYYY') {            const partes = dataStr.split('/');            if (partes.length === 3) {                return `${partes[2]}-${partes[0].padStart(2, '0')}-${partes[1].padStart(2, '0')}`;            }        }    } catch (e) {        return null;    }        return null;}/** * Detecta automaticamente o formato do arquivo */function detectarFormato(content, filename) {    const ext = filename?.toLowerCase().split('.').pop();        if (ext === 'ofx' || ext === 'qfx') {        return 'OFX';    }        if (ext === 'csv' || ext === 'txt') {        return 'CSV';    }        // Detectar pelo conteúdo    if (content.includes('<OFX>') || content.includes('OFXHEADER')) {        return 'OFX';    }        // Assumir CSV se não for OFX    return 'CSV';}/** * Detecta automaticamente as opções do CSV */function detectarOpcoesCSV(content) {    const linhas = content.split(/\r?/).filter(l => l.trim());        if (linhas.length < 2) {        return { separador: ';', temCabecalho: false };    }        const primeiraLinha = linhas[0];        // Detectar separador    let separador = ';';    if (primeiraLinha.split(',').length > primeiraLinha.split(';').length) {        separador = ',';    } else if (primeiraLinha.split('\t').length > primeiraLinha.split(';').length) {        separador = '\t';    }        // Detectar cabeçalho    const colunas = primeiraLinha.split(separador);    const temCabecalho = colunas.some(c =>         /data|date|descri|hist|valor|amount|tipo|saldo/i.test(c)    );        // Detectar colunas    let colunaData = 0;    let colunaDescricao = 1;    let colunaValor = 2;    let colunaTipo = null;        colunas.forEach((col, idx) => {        const colLower = col.toLowerCase();        if (/data|date|dt/i.test(colLower)) colunaData = idx;        if (/descri|hist|memo|obs/i.test(colLower)) colunaDescricao = idx;        if (/valor|amount|vlr|val/i.test(colLower)) colunaValor = idx;        if (/tipo|type|d\/c|dc|nat/i.test(colLower)) colunaTipo = idx;    });        return {        separador,        temCabecalho,        colunaData,        colunaDescricao,        colunaValor,        colunaTipo    };}/** * Função principal de parsing */function parseExtrato(content, filename, opcoes = {}) {    const formato = detectarFormato(content, filename);        if (formato === 'OFX') {        return parseOFX(content);    }        // CSV - detectar opções automaticamente se não fornecidas    const opcoesCSV = {        ...detectarOpcoesCSV(content),        ...opcoes    };        return parseCSV(content, opcoesCSV);}module.exports = {    parseOFX,    parseCSV,    parseExtrato,    detectarFormato,    detectarOpcoesCSV};